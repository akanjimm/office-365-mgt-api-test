// Import polyfills for fetch required by msgraph-sdk-javascript.
require("isomorphic-fetch");
const teamsfxSdk = require("@microsoft/teamsfx");
const fetch = require("node-fetch"); // to install, use npm install node-fetch@2
const { Connection, Request } = require('tedious');

const config = require("../config");
const msal = require('@azure/msal-node');

/**
* @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} { [key: string]: any; } - The context generated by teamsfx binding.
 */
module.exports = async function (context, req, teamsfxContext) {
  context.log("HTTP trigger function processed a request.");
  let route = context.bindingData.route; // Get api route name
  let method = req.method.toLowerCase();
  let id = context.bindingData.id;

  try {
    // Prepare id token (also auth or sso token).
    const ssoToken = teamsfxContext["AccessToken"];
    if (!ssoToken) {
      return {
        status: 400,
        body: {
          error: "No access token was found in request header.",
        },
      };
    }

    // get access token through on-behalf-of flow
    let accessToken = await getAccessToken(ssoToken);

    // get access token to call Office365 management API (Audit Sharepoint)
    let accessTokenO365API = await getAccessTokenWithMsal(ssoToken);

    // Test: call office 365 management api
    // 1. subscribe to Audit.Sharepoint
    await establishSubToO365(accessTokenO365API)


    // Primary routing
    let response;
    switch (method) {
      case "get":
        response = await getRequestHandler(accessToken, route);
        break;
      case "post":
        response = await postRequestHandler(route, req);
        break;
      case "put":
        response = await putRequestHandler(route, id);
        break;
      case "delete":
        response = await deleteRequestHandler(route, id);
        break;
    }

    // return a response object to the client
    return {
      status: response.status || 200,
      body: response.data,
    };

  } catch (error) {
    return {
      status: error.status || 500,
      body: {
        error: error.message || "Unable to execute request"
      }
    }
  }
};


// Secondary routing
async function getRequestHandler(accessToken, route) {
  try {
    let data, query;
    switch (route) {
      case "consent":
        data = true;
        break;
      case "user":
        data = await getSignedInUserData(accessToken); // get signed in user's Microsoft 365 data
        break;
    }

    // if the switch...case statement results in a query, a database call is made
    if (query) {
      try {
        data = await getResultFromDatabase(query);
      } catch (error) {
        throw error;
      }
    }

    return {
      status: 200,
      data: data
    }
  } catch (error) {
    throw { status: 500, message: "Unable to fetch data." };
  }
}

async function postRequestHandler(route, req) {
  // logic comes here
}

async function putRequestHandler(route, id) {
  // logic comes here
}

async function deleteRequestHandler(route, id) {
  // logic comes here
}

// function to exchange sso token for access token on-behalf-of the user from Azure AD
async function getAccessToken(ssoToken) {
  try {
    const tokenEndpoint = `https://login.microsoftonline.com/${config.tenantId}/oauth2/v2.0/token`;

    let Headers = new fetch.Headers();
    Headers.append('Content-Type', 'application/x-www-form-urlencoded');

    let urlencoded = new URLSearchParams();
    urlencoded.append('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer');
    urlencoded.append('client_id', config.clientId);
    urlencoded.append('client_secret', config.clientSecret);
    urlencoded.append('assertion', ssoToken);
    urlencoded.append('scope', "User.Read");
    urlencoded.append('requested_token_use', 'on_behalf_of');

    let options = {
      method: 'POST',
      headers: Headers,
      body: urlencoded
    };

    let response = await fetch(tokenEndpoint, options);
    if (response.ok) {
      let tokenData = await response.json();
      return tokenData.access_token;
    } else {
      let responseText = await response.text();
      if (JSON.parse(responseText).error === "invalid_grant") {
        throw { status: 401, message: "invalid_grant: You or an administrator needs to consent to required permission(s)." };
      } else {
        throw { status: 400, message: "Unable to get access token." };
      }
    }
  } catch (err) {
    throw { status: err.status || 500, message: (err.status && err.status < 500) ? err.message : "Unable to get access token." };
  }
}

// function to get signed in user's Microsoft 365 data
async function getSignedInUserData(accessToken) {
  let userEndpoint = "https://graph.microsoft.com/v1.0/me"
  let userOptions = {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-type': 'application/json',
      'Accept': 'application/json',
      'Accept-Charset': 'utf-8',
      'ConsistencyLevel': 'eventual'
    },
  };

  try {
    let response = await fetch(userEndpoint, userOptions);
    if (response.ok) {
      let userData = await response.json();
      return userData;
    } else {
      throw { status: 500, message: "Unable to get user's Microsoft 365 data." };
    }
  } catch (err) {
    throw { status: 500, message: "Unable to get user's Microsoft 365 data." };
  }
}

/* *********** OFFICE 365 MANAGEMENT API FUNCTIONS *********** */
// function to get access token for authorization with O365 management api endpoints
async function getAccessTokenWithMsal() {
  const msalConfig = {
    auth: {
      clientId: config.clientId,
      authority: `https://login.microsoftonline.com/${config.tenantId}`,
      clientSecret: config.clientSecret,
      knownAuthorities: [],
    }
  }
  const cca = new msal.ConfidentialClientApplication(msalConfig);
  const clientCredentialRequest = {
    scopes: ["https://manage.office.com/.default"],
  };

  try {
    let response = await cca.acquireTokenByClientCredential(clientCredentialRequest)
    return response.accessToken
  } catch (error) {
    // Todo: remove console logs and replace with necessary action
    console.log(">>>>>>>>> error", error)
  }
}

// subscribe to office 365 management api to get sharepoint audit data
async function establishSubToO365(accessToken) {
  let rootUrl = `https://manage.office.com/api/v1.0/${config.tenantId}/activity/feed`
  let contentType = "Audit.SharePoint"
  let url = `${rootUrl}/subscriptions/start?contentType=${contentType}`
  let options = {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-type': 'application/json',
      'Accept': 'application/json',
      'Accept-Charset': 'utf-8',
    },
  };

  try {
    let response = await fetch(url, options);
    if (response.ok) {
      let data = await response.json();
      // Todo: remove console logs and replace with necessary action
      console.log("##################################1");
      console.log(data)
    } else {
      let errorText = await response.text();
      // Todo: remove console logs and replace with necessary action
      console.log("##################################2");
      console.log(errorText)
    }
  } catch (err) {
    // Todo: remove console logs and replace with necessary action
    console.log("##################################3");
    console.log(err)
  }
}



/* *********** end *********** */


// Create connection to SQL Server database
async function getSQLConnection(teamsfx) {
  const tediousConfig = {
    authentication: {
      options: {
        userName: config.sqlUsername,
        password: config.sqlPassword,
      },
      type: 'default'
    },
    server: config.sqlEndpoint,
    options: {
      database: config.sqlDatabaseName,
      encrypt: true
    }
  };
  const connection = new Connection(tediousConfig);
  return new Promise((resolve, reject) => {
    connection.on('connect', err => {
      if (err) {
        reject(err);
      }
      resolve(connection);
    })

    connection.on('debug', function (err) {
      console.log('debug:', err);
    });

    connection.connect()
  })
}

// Query connected SQL database
async function execQuery(query, connection) {
  return new Promise((resolve, reject) => {
    const res = [];
    const request = new Request(query, (err) => {
      if (err) {
        reject(err);
      }
    });

    request.on('row', columns => {
      const row = {};
      columns.forEach(column => {
        row[column.metadata.colName] = column.value;
      });
      res.push(row)
    });

    request.on('requestCompleted', () => {
      // add request object to response {res, request}
      resolve(res)
    });

    request.on("error", err => {
      reject(err);
    });

    connection.execSql(request);
  })
}

async function getResultFromDatabase(query) {
  try {
    const connection = await getSQLConnection();
    const result = await execQuery(query, connection);
    connection.close(); // close sql database connection after executing query
    return result
  } catch (error) {
    throw (error);
  }
}